#面向对象之封装
作用：使类型安全、易用。需要的成员才暴露给使用者，不需要的保护起来

好处：提高安全性，提高复用性，将复杂的事情简单化。

使用方式：方法，类；

#面向对象之继承
作用：使子类拥有了父类的非私有型变量（成员方法，成员变量）；

好处：实现代码复用，简化代码；

使用场景:多个类中存在相同的属性和行为时，可以将这些内容提取出来放到一个新类中，让这些类与新类产生父子关系，实现代码复用；

使用方式： public class 类名 extends 类名

#面向对象之多态
作用：降低程序的耦合度，写一个类不仅用多次，而且可以被不同的场景使用，提高了代码的复用性；

使用场景：一个事物有着不同状态时

使用步骤：

1 要有继承关系

2 要有方法重写

3父类引用指向子类对象



向上转型(自动类型转换）子类型转换成父类型

Animal an=new Dog();

向下转型（强制类型转换）父类型转换成子类型

if（an instanceof Dog)
{
}需要先判断an是否为Dog类的对象

Dog dog=(Dog) an;


#集合之Arraylist
作用：动态数组，可以灵活地设置数组的大小，同时为有序集合（插入的顺序等于输出的顺序），同时里面的元素可重复，查找效率高；

使用方式：List list=new ArrayList;

使用场景：需要快速随机访问元素时

#集合之Linkedlist
作用：作为链表或者双向队列来使用

使用方式：LinkedList list =new LinkedLisw;

使用场景：需要快速插入，删除元素时

#集合之HashSet
作用：动态数组，输出顺序为无序，而且里面的元素不能重复,即元素唯一，而且数据存放数据无序

使用方式：Set set=new Set;

使用场景：需要快速查找时，而且数据不能重复时

#集合之LinkedHashSet
作用：和HashSet差不多，不过成对元素存放进去有序

使用方式：LinkedHashSet set =new LinkedHashSet

 使用场景：需要快速查找时，而且数据不能重复时，需要取出时为有序时
#集合之HashMap
作用：key与value一一对应，键值对的集合,key不可重复且无序，查找的效率很高.

使用方式：Map<T,V>map=new Hashmap<>();

使用场景：需要通过一些键盘值的输入可以找到对应的内容时

#集合之LinkedHashMap
作用：key与value一一对应，键值对的集合,key不可重复且有序，查找的效率很高.

使用方式：LinkedhashMap<T,V>map=new LinkedHashmap<>();

#泛型
作用：提高类型安全，消除强制类型转换

使用场景：集合，泛型类，泛型接口，泛型方法；


#异常处理；
作用：可以让程序具有更好的容错性，可以预防错误的程序代码或系统错误所造成的不可预期的结果发生。减少编程人员的工作，增加了程序的灵活性和可读性；

使用方式：

try{}catch{}(finally)...

throws



使用场景：

对于try{}catch{}(finally)...，通常使用于最后finally处需要释放资源的时候以及对于某些不确定的地方如果出错了需要解决方案来替代的地方

对于throws...通常使用于不需要对可能会出错的地方进行解决的地方。

多个异常使用捕获如何处理：

1.多个异常分别处理；

2.多个异常一次捕获，多次处理

3.多个异常一次捕获一次处理；



#注解
 单行注释 // 注释内容 

 多行注释 /* 注释内容 */

 文档注释 /** 注释内容 */


#IO流
作用：读数据和写数据；

使用方法：

字节流(纯文本、doc、音频、视频等)：

Inputstream:字节输入流的顶层抽象类

FileInputStream：普通的字节输入流

BufferedInputStream：字节缓冲输入流（高效）

OutPutStream:字节输出流的顶层抽象类

FileInputStream：普通的字节输出流（高效）

BufferedInputStream：字节缓冲输出流


字符流(文本文件，只能处理纯文本)：
Reader:字符输入流的顶层抽象类

FileReader:普通的字符输入流（小内容）

BufferedReader:字符缓冲输入流(高效，通常用于例如文本，文件的复制这种需要比较大的工程量的））

Writer:字符输出流的顶层抽象类

FileWriter:普通的字符输出流

BufferedWriter:字符缓冲输出流（高效）

使用场景：数据保存，数据读取；























